3种常见加密算法：
    对称加密算法、非对称加密算法、Hash算法
### 对称加密：
    对称加密分为流加密和分组加密，其特点是加密、解密使用同一种密钥。
> * 优点：算法公开、计算量小、加密速度快、加密效率高。
> * 缺点：数据传送前，发送方和接收方需要商定好密钥并保存，一旦其中一方密钥泄露，那么加密信息就不安全了。
> * 使用场景：本地数据加密解密、https通信、网络传输等。
> * 常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6。其中IDEA（国际数据加密算法）相比于DES（数据加密标准），加密性更好，而且对计算机性能要求也没那么高。
### 非对称加密：
    非对称加密，即加密、解密使用不同的规则，这两种规则之间存在某种对应关系，从而避免直接传递密钥。
> * 优点：相比于对称加密，安全性更好。
> * 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
> * 使用场景：https会话前期、CA数字证书、信息加密、登录认证等。
> * 常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）

### Hash算法：
    Hash算法是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个值重新获得目标信息。
> * 优点：不可逆、易计算、特征化。
> * 可能存在散列冲突。
> * 使用场景：文件或字符串一致性校验、数字签名、鉴权协议
> * 常见算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1

### RSA算法推导
#### 数论基础
1. 互质关系：如果两个正整数，除了1以外没有其他公因子，我们就称这两个数是互质关系（coprime）。
2. 任意一个大于1的正整数，都可以写成一系列质数的积。
    $n=p_1^{k_1}p_2^{k_2}...p_r^{k_r}$
3. 欧拉函数的通用计算公式:$\phi(n) = n(1-{1\over p_1})(1-{1\over p_2})...(1-{1\over p_r})$
4. 欧拉定理：如果两个正整数a和n互质，则$a^{\phi(n)}-1$ 能整除 n，即   
   $a^{\phi(n)}-1 = n \times b$ (b为正整数)
5. 模反元素：如果两个正整数a和n互质，那么一定可以找到正整数x，使得ax-1能整除n，此时x就叫做a的模反元素。   
   $a^{\phi(n)} = a * a^{\phi(n)-1}$   
   $a^{\phi(n)}-1 = n \times b$ (b为正整数)   
   $a * a^{\phi(n)-1} - 1 = n\times b$   
   即$a * a^{\phi(n)-1} - 1$能整除n，则x为$a^{\phi(n)-1}$   
   得到结论：如果两个正整数a和n互质，那么a必有一个模反元素是$a^{\phi(n)-1}$ 
6. 如果x是a对于n的某一个模反元素，那么$x+kn$（k是整数）都是a的模反元素

#### RSA密钥生成过程
1. 随机选择两个不相等的质数p和q。实际应用中，这两个质数越大越难破解。
2. 计算p和q的乘积。
   $n = p \times q$   
   n的长度就是密钥的长度，将n写成二进制有多少位，即密钥就有多少位。实际应用中RSA密钥一般是1024位，重要场合则是2048位。
3. 计算n的欧拉函数$\phi(n)$   
   根据$n = p_1^{k_1}p_2^{k_2}...p_r^{k_r} = p \times q$   
   得到$\phi(n) = n(1-{1\over p_1})(1-{1\over p_2})...(1-{1\over p_r}) = n(1-{1\over p})(1-{1\over q}) = n{{(p-1)(q-1)}\over{p \times q}} = (p-1)(q-1)$   
   即$\phi(n) = (p-1) \times (q-1)$
4. 从1～$\phi(n)$之间随机选择一个正整数e，满足$1<e<\phi(n)$ 且 e与$\phi(n)$互质。实际应用中常常选择65537
5. 计算e对于$\phi(n)$的模反元素d   
   即存在一个正整数k使得$ed - 1 = k\phi(n)$ 令x=d, y = -k   
   即$ex + (p-1) \times (q-1)y = 1$   
   通过辗转相除法可以得到上面二元一次函数的某组解，那么可以得到一个模反元素d的值   
   再根据<font color = red>如果x是a对于n的某一个模反元素，那么$x+kn$（k是整数）都是a的模反元素</font>，那么通过 $d = d + k\phi(n)$（k是整数）修正d的值，让其最好是正整数方便后续计算。
6. 至此我们已经得到了e和d的值，将n和e封装成公钥（n，e）发布，n和d封装成私钥（n，d）保存。在仅知道n和e的前提下，要想推导出d的值，必须要将n因数分解得到p和q的值才行，可是大整数的因数分解相当困难，所以RSA算法是很可靠的。

#### RSA加密解密过程
1. t使用公钥