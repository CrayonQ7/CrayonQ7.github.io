---
title: Unity渲染流水线简述
tags: Unity Shader学习笔记
---

# Unity引擎基础

## Unity3D介绍

> 游戏引擎：程序的框架，一款游戏最核心的代码。包含以下系统：渲染引擎、物理引擎、碰撞检测系统、音效、脚本引擎、动画系统、人工智能、网络引擎，以及场景管理。  

在 Unity 中创建新项目时，可以选择以 2D 或 3D 模式启动

* **全3D**：3D 游戏通常使用三维几何体，在游戏对象的表面上渲染材质和纹理，使它们看起来像构成游戏世界的坚固环境、角色和对象。摄像机可以在场景中及其周围自由移动，并以逼真的方式在游戏世界中投射光线和阴影。3D 游戏通常使用透视渲染场景，因此当对象靠近摄像机时，对象在屏幕上显得更大。对于符合此描述的所有游戏，请采用 **3D** 模式。
* **正交 3D**：有时游戏使用 3D 几何体，但使用正交摄像机，而不是透视。这是游戏中常用的技巧，可用于对动作进行鸟瞰，有时也称为“2.5D”。如果要制作这样的游戏，还应该在 3D 模式下使用 Editor，因为即使没有透视，仍将使用 3D 模型和资源。但此情况下需要将摄像机和 Scene 视图切换为**正交 (Orthographic)** 视图。
* **全2D**：许多 2D 游戏使用平面图形，有时称为精灵（没有任何三维几何体）。它们作为平面图像被绘制到屏幕上，而且游戏的摄像机没有透视。对于这种类型的游戏，应该以 **2D** 模式启动 Editor。
* **包含 3D 图形的 2D 游戏玩法**：一些 2D 游戏将 3D 几何体用于环境和角色，但将游戏玩法限制为二维模式。例如，摄像机可以显示横向卷轴视图，并且玩家只能在两个维度上移动，但是游戏本身仍然将 3D 模型用于障碍物并且将 3D 透视用于摄像机。对于这些游戏，3D 效果的用途可能是为了营造风格，而不是充当某种功能。这种类型的游戏有时也被称为“2.5D”。尽管游戏玩法是 2D，但主要是操纵 3D 模型来构建游戏，因此应该以 **3D** 模式启动 Editor。
* **带有透视摄像机的 2D 游戏玩法和图形**：这是另一种流行的 2D 游戏风格，使用 2D 图形，但通过透视摄像机来获得视差卷轴效果。这是一个“纸板剧院”风格的场景，所有图形都是平面的，但按照与摄像机之间的不同距离排列。在这种情况下，**2D** 模式最有可能符合开发要求。但是，应将摄像机的投影模式更改为**透视 (Perspective)**，并将 Scene 视图模式更改为 **3D**。

## 操作介绍

* Project面板对应asstes，放游戏资源（资源可以直接拖入unity里 或者打包成unitypackage之后再导入）
* Hierarchy面板放游戏对象
* Scene面板 场景布局
* Game面板 游戏运行后的界面
* alt+鼠标左键：围绕旋转
* alt+右键：缩放场景
* Scene里选中物体后按F 或Hierarchy面板双击物体：物体居中
* 按下鼠标滚轮拖动场景，滑动滚轮缩放场景
* 鼠标右键旋转场景，左键移动场景
* 鼠标右键同时按W A S D：场景漫游
  
## 基础概念

* 视角：透视、正交
* GameObject：游戏对象
* Component：游戏对象的功能模块
  * Transform组件：决定物体的位置、旋转、缩放比
  * Mesh Filter网格过滤器：从资源中获取网格信息。 Mesh可以理解为 物体的形状。
  * Mesh Renderer 网格渲染器：从网格过滤器中获得几何形状，再根据变化组件定义的位置渲染
  > 网格过滤器和网格渲染器结合，使模型显示到屏幕上
* Matrial决定外观
* 通常我们会把模型加到一个空物体里，然后再把组件加到空物体上，这样后续模型更改之后不至于重新添加组件
* 物体是一个容器，不是用来装某一个游戏资源的，他是用来装组件的，而组件是通过mesh render渲染的，它需要材质。即材质是添加到mesh renderer组件上去的
* unity5.x的重大革新：PBS 物理着色器，基于物理规律，可以创建出在不同光照下接近于真实的效果

## 材质Material

材质包括了 纹理（贴图）、色彩、光滑度、透明度、反射率、折射率、发光度等。实际就是**Shader**的实例。

* 材质里有一个叫“渲染模式”的东西
  * Opaque 不透明的
  * Cutout 会去掉透明通道，只显示不透明的部分。 即 剪裁、镂空，用于完全透明或完全不透明物体
  * Fade 淡入淡出（需要设置颜色Albedo里透明度的值 即RGBA中A的值）
  * Transparent 透明 （需要设置颜色Albedo里透明度的值 即RGBA中A的值），用于半透明和全透明物体，如玻璃
* **Shader**（着色器）是专门用来渲染图形的技术，可以使纹理以某种方式展现。实际就是一段嵌入到渲染管线中的程序，可以控制GPU运算图像效果的算法。可以理解为 **Material** 就是 一个用来配具体**Shader**数值的一个面板
* **Shader**要给到材质 然后材质再给到物体，修改材质上的属性，进行效果调整
  
## Camera

带有**camera**组件的，就叫“相机”。通常还会伴随组件：

* Transform：用于调整相机位置和旋转（对相机缩放是没用的）
* Flare Layer耀斑层：激活可显示光源耀斑
* GUI Layout：激活可渲染二位GUI元素（很少用 基本废弃掉了）
* Audio Listener 音频监听器：接收场景输入的音频源Audio Source并通过计算机的扬声器播放声音。
* Camera：向玩家捕获和显示世界。
  * Clear Flags：屏幕空白区域怎么处理：skybox天空盒、solid color纯颜色、depth only仅深度（一般深度值大于主相机的相机才可能设置）、dont clear不清除（屏幕很容易花屏，基本不用）
  > 天空盒：围绕整个场景的包装器，用于模拟天空的材质，主要有3种：6 sided（6个面的，可添加6个贴图）， procedural（可以改变天、地的颜色、太阳设置、），cube
  > 使用方法：
  > 1. 设置相机Clear Flags属性为skybox
  > 2. 给摄像机添加组件 skybox  或者 通过光照窗口：一般在windows—>rendering->ligthing settings -> skybox ，可作为反射源将天空色彩反射到场景种的物体。（一般用后者）
  * Culling Mask：选择遮罩，只有这个选项选中的层级才能被渲染
  * Projection：透视的(Perspective)，正交的（Orthographic，忽略了纵深的轴，即2d模式）
  * Field of View(fov)：相机视野
  * Clipping Planes：剪裁面
  * Viewport Rect：可以用来做小地图、分屏、后视镜
  * Depth：深度，越高的越早渲染
  
> 如何做一个小地图：
>
> 1. 添加一个相机到天上，设置相机Projection属性为正交，并设置其depth要高于主相机
> 2. 给模型添加一个遮罩层masklayer用于在小地图中显示
> 3. 在场景里添加一张场景的2d贴图并加入masklayer，然后设置相机Culling mask，只看masklayer，千万不要让小地图相机去看场景，会增加渲染量
> 4. 设置相机的clear flags为depth only，可以不渲染空白区域的内容

## 渲染管线

> 图形数据在GPU上经过运算处理，最后输出到屏幕的过程。

简易流程：

1. CPU判断出需要渲染的物体，交给图形api（DX、opengl，再通过Draw Call提交给GPU
   > Draw Call：每次引擎准备数据并通知GPU的过程。通俗讲，每帧调用显卡渲染物体的次数。在unity的status里叫batches。
2. GPU进行顶点处理
   * 接收模型顶点数据。任何一个模型都是由若干个三角形组成（网格）
   * 坐标系转换
3. GPU进行图元装配
   * 组装面：连接相邻的顶点，绘制为三角面
4. GPU进行光栅化
   * 计算三角面上的像素，比如深度值，并为后面着色阶段提供合理的插值参数
5. GPU进行像素处理
   * 对每个像素区域进行着色
6. 写入到缓存中
   > 缓存：一个存储像素数据的内存块，最重要的缓存是帧缓存与深度缓存
   * 帧缓存：存储每个像素的色彩，即渲染后的图像。帧缓存常常在显存中，显卡不断读取并输出到屏幕中
   * 深度缓存z-buffer：存储像素的深度信息，即物体到摄像机的距离。光栅化时，便于计算各像素的深度值，如果新的深度值比现有的近，则像素颜色被写到帧缓存，并替换深度缓存

我自己的简述：
> 渲染管线的流程大概是，CPU获取到场景数据（摄像机信息、模型、光源），进行粗粒度的剔除（剔除不可见的物体），设置渲染状态后通过DrawCall将渲染图元给到GPU。GPU接收数据之后进行一个顶点处理，包括坐标系的转换、顶点着色，然后进行图元的装配，连接相邻的顶点投影为三角面，然后可能会有一个裁剪的操作，剪掉不在摄像机视野内的顶点，剔除某些三角图元的面片，对剩下的图元进行屏幕映射，将图元转换到屏幕坐标系中，然后进行光栅化，计算光栅化三角形网格所需的信息，比如三角形边界的表示方式，然后遍历这些三角形，检查每个像素是否被三角形网格覆盖，是就生成一个片元，然后逐片源着色，并写入缓存。

**遮挡剔除**

* 即时遮挡剔除Instant Occlusion Culling
* 遮挡剔除：当物体被送进渲染流水线之前，将摄像机视角内看不到的物体进行剔除，从而减少每帧的渲染数据量，提高渲染性能。
* 实现方法：从摄像机随机地发送射线，能打到物体上box collider，说明没被遮挡

缺点：判断物体是否被遮挡，CPU有额外开销。

场景中存在大量分布密集的物体，此时，适合用遮挡剔除。

**多细节层次 LOD**

LOD技术(Levels of Detail)指根据物体模型的节点在显示环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。比如距离相机位置近的模型可以使用精模，距离远的可以降低其面数量。

## 光照系统

> GI 全局光照 global illumination：能够计算直接光、间接光、环境光以及反射光的光照系统。通过GI算法可以使渲染出来的光照效果更为真实丰富。

1. 直接光照：通过light组件发出的光
   **Type**：
    * Directional Light 平行光：向着自己的z轴平行发射光线，可以照射场景里所有物体，跟位置无关，只和方向、角度有关，用来模拟太阳
    * Point Light 点光源： 由一个点向四周发射光线 形成一个球，在球形以内才能感知到光   可以模拟灯泡
    * Spot Light 聚光灯：  由一个点向一个锥体区域发射光，只有这个区域内的物体才会受到光线照射，可以模拟探照灯、手电筒
    * Area Light 区域光：由一个面向一个方向发射光线，只照射该区域内物体，仅烘培时有效，用在光线较为集中的区域。
  **属性设置**：
    * Range 范围：光从物体的中心发射的范围。仅适用于点光源和聚光灯。
    * Spot Angle 聚光角度：灯光的聚光角度。只适用于聚光灯。
    * Color 颜色：光线的颜色。
    * Intensity 强度：光线的明亮程度。
    * Culling Mask 选择遮蔽层：选择要照射的层Layer。
    * Shadow Type 阴影类型：Hard、Soft、
       从性能角度讲，如果硬阴影能满足需求，就用硬的。

       如果个别物体不需要阴影怎么办？（因为阴影是非常消耗性能的，个别物体可以取消掉）
       可以在物体的Mesh Renderer组件里设置Cast Shadows投射阴影、receive shadows接收阴影
    可以在edit/project settings/quality里设置阴影的剔除距离
2. 环境光
    作用于场景内所有物体的光照，通过Environment Light中ambient控制，
3. 反射光
    根据天空盒或立方体贴图计算的作用于所有物体的反射效果，通过Environment Light中Reflection控制
4. 间接光照
    物体表面在接收光照后反射出来的光。
    通过light组件中bounce intensity反弹强度控制
    可以通过scene 面板 irradiance模式查看间接光照
    将场景的不动的物体设置为静态，会有一个预计算的过程，把物体的信息计算缓存，在游戏运行之后，只需要做光线追踪即可。

### -

#### 实时GI

    所谓实时，是指在运行期间任意修改光源，而所有光源可以立即更新。
    手游里基本不用这个，PC一般才用

#### 烘焙GI

    烘焙 Lightmap：
    场景中包含大量物体时，实时光照和阴影对游戏性能有很大影响。
    使用烘焙技术，可以将光线效果预渲染成贴图再作用到物体上模拟光影，从而提高性能。
    适用于在性能较低的设备上运行的程序。
    1. 把场景里不动的物体标记为静态
    2. 找到光的baking属性

#### 光源侦测

    由于Lightmapping 只能作用于static物体，所以导致运动的物体与场景中的光线无法融合在一起，显得非常不真实。
    而light probes组件可以通过probe收集光影信息，然后对运动物体临近的几个probe进行插值运算，最后将光照作用到物体上。
    在烘焙前给场景加上游戏对象Light Probe Group，再烘焙，这样就能保存光影信息
    然后给需要侦测物体的Mesh renderer组件的use light probes属性勾选
    对烘焙的弥补。

## 声音

声音分为2d和3d

* 3d声音：有空间感，近大远小
* 2d声音：适合背景音乐
  * 在场景中产生声音，主要依靠两个组件：
    * Audio Listener：接收场景中音频源Audio Source发出的声音，通过计算机的扬声器播放声音（这个组件一般在camera中）
    * Audio Source 音频源
